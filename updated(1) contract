// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "erc721a/contracts/ERC721A.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/utils/Counters.sol";

contract Audeamus is ERC721A, Ownable{
  using Strings for uint256;
  bytes32 private merkleRoot ; 
  string private  baseTokenUri;
    string public   placeholderTokenUri;

    uint256 public reservedForTeam = 10;
    uint256 public initialPublicPrice = 0.4 ether;
    uint256 public whiteListPrice = 0.2 ether;

    uint256 public constant MAX_PUBLIC_SUPPLY = 9000;
    uint256 public constant MAX_WHITELIST_SUPPLY = 3000;
    uint256 public constant MAX_WHITELIST_MINT = 2;
    uint256 public constant MAX_PUBLIC_MINT = 10;
    uint public  startAt;
    uint public  endAt;
    uint public  discountRate;
    uint public DURATION = 7 days;
   mapping(address => uint256) public totalPublicMint;
   mapping(address => uint256) public totalWhiteListMint;     
    bool public saleActive = false;
    bool public whitelistActive = false;
    bool public revealed = false;
    bool public paused = false;
    bool public teamMint = false;
    constructor() ERC721A('Audeamus', 'AUD') {
      
    }
     modifier callerIsUser() {
        require(tx.origin == msg.sender, "Please do not call this contract using another contract");
        _;
    }

    
     
    function mintReserved (uint256 _amount) public onlyOwner{
        require(!teamMint, 'Team has already minted');
        reservedForTeam = _amount;
        teamMint = true;
        _safeMint(msg.sender, _amount);
        
    }

    function getPrice() public view returns(uint) {
        uint timeElapsed = block.timestamp - startAt;
        uint discount = timeElapsed *  discountRate/100 ;
        return initialPublicPrice - discount;
    }

    function whiteListMint(bytes32[] calldata _merkleproof, uint256 _amount) external payable callerIsUser {
        require(whitelistActive, 'white list not active yet');
        require(totalSupply() + _amount <= MAX_WHITELIST_SUPPLY, 'The pre market white list sale limit has been hit.');
        require(msg.value >= whiteListPrice * _amount, 'Insufficient ether');
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

        require(MerkleProof.verify(_merkleproof, merkleRoot, leaf), 'Invalid Proof');
        require(totalWhiteListMint[msg.sender] + _amount <= MAX_WHITELIST_MINT, 'Maximum of two mints per transaction');
        totalWhiteListMint[msg.sender] += _amount;
        _safeMint(msg.sender, _amount);
    }

    function publicSaleMint(uint256 _quantity) external payable callerIsUser {
      require(saleActive, 'Sale has not begun yet');
      require(!paused, 'Sale has been paused');
      require(totalSupply() + _quantity <= MAX_PUBLIC_SUPPLY, 'The public sale limit has been hit.');   
      require(msg.value >= (getPrice() * _quantity), 'Insufficient ether');
      require(totalPublicMint[msg.sender] + _quantity <= MAX_PUBLIC_MINT, 'You have already minted 10 times');

      totalPublicMint[msg.sender] += _quantity;
      _safeMint(msg.sender, _quantity);
   }

    function _baseURI() internal view virtual override returns (string memory) {
        return baseTokenUri;
    }

    
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        uint256 trueId = tokenId + 1;

        if(!revealed){
            return placeholderTokenUri;
        }
       
        return bytes(baseTokenUri).length > 0 ? string(abi.encodePacked(baseTokenUri, trueId.toString(), ".json")) : "";
    }

     function setTokenUri(string memory _baseTokenUri) external onlyOwner{
        baseTokenUri = _baseTokenUri;
    }
    function setPlaceHolderUri(string memory _placeholderTokenUri) external onlyOwner{
        placeholderTokenUri = _placeholderTokenUri;
    }

    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner{
        merkleRoot = _merkleRoot;
    }

    function getMerkleRoot() external view returns (bytes32){
        return merkleRoot;
    }

    function togglePause() external onlyOwner{
        paused = !paused;
    }

    function toggleWhiteListSale() external onlyOwner{
        whitelistActive = !whitelistActive;
    }

    function togglePublicSale() external onlyOwner{
        saleActive = !saleActive;
    }

    function toggleReveal() external onlyOwner{
        revealed = !revealed;
    }
    function withdraw() external onlyOwner {
        require(address(this).balance > 0);
        payable(owner()).transfer(address(this).balance);
    }
  }
